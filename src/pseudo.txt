coeffs1 = userinput coeffs
poly1 = polynomial with coeffs1 modulo (user mod)
n = greatest degree

В моей программе коэффициенты записываются от младшего к старшему. Например {6, 0, 3, 0, 0, 1} при x^5+3x^2+6

Псевдокод:
- Считываются коэффициенты полинома coeffs1
- Считывается значение модуля mod (простое число)
- Создается полином poly1 на основе введенных пользователем коэффициентов coeffs1 (объект класса Polynomial)
- Высчитывается значение старшей степени многочлена (переменная n)
- Затем создается двумерный массив coeffs2 с n строками, где размер каждой из которых определяется формулой  ((mod*(i))+1), где i - индекс строки (от 0 до n-1)
- Создается матрица Q, где каждая i-ая строка - это остатки от деления полинома с коэффициентами из i-ой строки coeffs2 на полином poly1
- Матрица Q заполняется нулями, чтобы принять вид квадратной матрицы.
- Матрица Q транспонируется
- Из транспонированной матрицы Q вычитается единичная матрица E такого же размера (получаем матрицу QTminusE)
- Каждый элемент матрицы QTminusE приводися по модулю mod
- Приводим матрицу QTminusE к ступенчатому виду при помощи метода Гаусса
- Каждый элемент матрицы QTminusE приводися по модулю mod
- Считается ранг (rank) ступенчатой матрицы QTminusE
- Каждая ненулевая строка записывается в новую матрицу resultMatrix
- Считается количество множителей (k = n = rank). Если k<=1 решений нет.
- Создается матрица FSRMatrix для хранения фундаментальной системы решений. В нее записывается значение базиса пространства решений однородной системы (в данном случае - на вход подается матрица resultMatrix)
- Удаляем первую строку матрицы FSRMatrix
- Создается массив polys для хранения полиномов 
- В массив polys поэлементно записываются объекты класса Polynomial (полиномы) на основе строк матрицы FSRMatrix (каждая строка - коэффициенты одного полинома)
- Отдельно выделяем строку с индексом 0 из матрицы FSRMatrix как полином с коэффициентами coeffs3
- Создаем массив resultants для хранения результантов
- Создается матрица Сильвестра от переменных coeffs1 и coeffs3 размером (n1+n3), где n1 - максимальная степень полинома с коэффициентами coeffs1, а n3 - максимальная степень полинома с коэффициентами coeffs3. Также на вход подается переменная "c", которая равна от 0 до (mod-1)
	(как создается матрица сильвестра)
	- на вход подаются коэффициенты coeffs1, coeffs3, значение "c"
	- размер матрицы matrixSize равен (n1+n3), где n1 - максимальная степень полинома с коэффициентами coeffs1, а n3 - максимальная степень полинома с коэффициентами coeffs3
	- создается пустая матрица сильвестра sylvesterMatrix размером matrixSize на matrixSize.
	- матрица сильвестра sylvesterMatrix заполняется сначала коэффициентами coeffs1, затем coeffs3
	- потом, левее от коэффициентов coeffs3, в матрицу сильвестра записывается значение коэффициента при младшей степени минус значение "c"
- Далее в каждый c-ый элемент массива resultants записывается значение определителя матрицы сильвестра sylvesterMatrix от входных данных coeffs1, coeffs3, c, где c от 0 до mod-1
- Создается массив корней. В него записываются индексы массива resultants, где значение получилось равно нулю.
- Создается матрица adjustedPolys
- В каждую строку adjustedPolys записываются коэффициенты полученные путем вычитания коэффициентов на основе значения массива корней (значения берутся как коэффициенты нового полинома) из коэффициентов coeffs3.
- Создается результирующая матрица resultPoly, куда записываются ненулевые строки матрицы adjustedPolys.
- Определяется самая старшая степень maxDeg среди всех полиномов на основе коэффициентов строк resultPoly
- Создается матрица коэффициентов resultPolyMatrix с количеством строк, равное resultPoly, но размер каждой строки равен maxDeg
- Матрица resultPolyMatrix заполняется коэффициентами из матрицы resultPoly
- Ответом явлется произведение полиномов, каждый из которых получается путем высчитывания gcd между poly1 и полиномом на основе коэффициентов i-ой строки resultPolyMatrix.
